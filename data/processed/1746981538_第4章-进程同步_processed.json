{
  "original_filename": "1746981538_第4章-进程同步.pdf",
  "processed_at": "2025-05-12T00:38:59.453222",
  "chunks": [
    {
      "text": "--- 第1页 ---\n1\n第\n4\n章\n进程管理\n4.1  进程同步的基本概念\n4.2  软件同步机制\n4.3  硬件同步机制\n4.4  信号量机制\n4.5  管程机制\n2.6 经典的进程同步问题\n\n--- 第2页 ---\n同步与互斥 的学习目标\n\n一组相关概念：\n 同步、互斥、临界资源\n /\n临界\n区、信号量\n\n同步、互斥的解决方法：\n\n比较经典问题的解决方法：\n 生产者\n /\n消费\n者问题、读者\n /\n写者问题、哲学家进餐问题\n\n--- 第3页 ---\n同步与互斥 的引入\n●OS引入进程后， 虽然显著地提高了系统\n的吞吐量，但是 由于进程的异步性，可能\n会导致程序执行结果的不确定性，使程序\n执行时出现不可再现性。\n●进程互斥与同步的主要任务是使并发执\n行的诸进程之间能有效地共享资源和相互\n合作，从而使程序的执行具有可再现性 。\n\n--- 第4页 ---\n两种制约关系\n在多道程序环境下，进程是 并发执行\n的，不同进程之间存在着不同的 相互\n制约关系 。\n直接相互制约关系（同步）\n间接相互制约关系（互斥）\n4\n\n--- 第5页 ---\n进程的同步（\n 1\n）\n直接相互制约关系（同步）\n指系统中一些进程需要相互合作，共同完成一项任\n务,这种协作进程之间相互等待对方消息或信号的\n协调关系称为 进程同步 .具体说，并发进程在一些\n关键点上可能需要互相等待与互通消息，进程间的\n相互联系是 有意识的安排的。\n产生的原因\n٭进程合作\n5\n\n--- 第6页 ---\n进程的同步（\n 2\n）\n一般同步问题有两类\n٭保证一组合作进程按逻辑需要的执行次序执行\n【例】司机 P1 售票员 P2\nREPEAT                 REPEAT\n启动 关门\n正常运行 售票\n到站停 开门\nUNTIL FALSE      UNTIL FALSE\n٭保证共享缓冲区（共享数据）的合作进程的同步\n【例】输入\n进程 PI缓冲区 缓冲区计算\n进程 PC打印\n进程 PP",
      "chunk_index": 0
    },
    {
      "text": "PP\n\n --- 第7页 ---\n是解决进程间竞争关系 (间接制约关系 )的手段。\n间接相互制约关系（互斥）\n٭是指若干个进程同时竞争一个 需要互斥使用的资源 时，\n任何时刻最多允许一个进程去使用，其他要使用该资源\n的进程必须等待，直到该资源被释放。进程间要通过某\n种中介发生联系，是 无意识安排的。\n产生的原因\n٭资源共享\n互斥是一种特殊的同步\n٭逐次使用互斥资源，也是对进程使用资源次序上的一种\n协调。\n7\n进程的互斥\n\n--- 第8页 ---\n8\n思考题\n【\n例\n】\n进程之间存在着哪几种制约关系？各是什么原\n因引起的？下列活动分别属于哪种制约关系？\n（\n1\n）\n若干同学去图书馆借书；\n（\n2\n）\n两队举行篮球比赛；\n（\n3\n）\n流水线生产的各道工序；\n（\n4\n）\n商品生产和社会消费间接相互制约关系（ 互斥）\n间接相互制约关系 （互斥）\n直接相互制约关系（ 同步）\n直接相互制约关系 （同步）\n\n--- 第9页 ---\n临界资源\n临界资源\n٭系统中某些资源 一次只允许一个进程使用 ，称\n这样的资源为 临界资源 或互斥资源 或共享变量 。\n٭硬件临界资源：打印机、磁带机\n٭软件临界资源：只能排它使用的变量、表格、\n队列\n9\n\n--- 第10页 ---\n临界资源实例\n二人合作存款\ncount:=100;\nPA  S1:N:=count;\nS2:N:=N+100;\nS3:count:=N;\n10PB  S4:M:=count;\nS5:M:=M+200;\nS6:count:=M;\n执行情况：\n（1）PA—> PB ,PB—> PA         count=400 √\n（2）S1—> PB—>S2—>S3        count=200 ×\n（3）S4—> PA—>S5—>S6        count=300 ×\n因count是一个互斥性使用的变量，是一个临界资源\n\n--- 第11页 ---\n临界区（临界段）\n٭在进程中访问临界资源的那段代码区。\n٭每次只允许一个进程进入临界区 。\n٭例子\n11\n临界区",
      "chunk_index": 1
    },
    {
      "text": "。\n٭例子\n11\n临界区\n\n --- 第12页 ---\n临界资源实例\n二人合作存款\ncount:=100;\nPA  S1:N:=count;\nS2:N:=N+100;\nS3:count:=N;\n12PB  S4:M:=count;\nS5:M:=M+200;\nS6:count:=M;\n执行情况：\n（1）PA—> PB ,PB—> PA         count=400 √\n（2）S1—> PB—>S2—>S3        count=200 ×\n（3）S4—> PA—>S5—>S6        count=300 ×\n因count是一个互斥性使用的变量，是一个临界资源\n\n--- 第13页 ---\n具有临界资源的进程结构\n…… \n/*进入区 */\ncritical  section;       /* 临界区 */\n/*退出区 */\nremainder section;  /* 剩余区 */\n……\n1\n3entry section\nexit section\n\n--- 第14页 ---\n访问临界区应遵循的\n 原则\n空闲让进\n当无进程处于临界区时，临界资源处于 空闲状\n态。此时允许 1个进程进入临界区。\n忙则等待\n当已有进程进入临界区时，临界资源正在被访\n问，其他想进入临界区的进程必须 等待。\n有限等待\n对于要求访问临界资源的进程，应保证在 有效\n的时间内进入，以免进入“死等”状态。\n让权等待\n当进程不能进入临界区时，应立即释放处理机\n，以免进程进入“忙等”。 14\n进入区\n临界区\n退出区\n剩余区\n\n--- 第15页 ---\n互斥和\n同步\n的\n实现\n方法\n软件同步 机制\n硬件同步机制\n关中断\nTest and set\nswap\n信号量机制\n整形信号量\n记录型信号量\nAND型信号量\n信号量集\n管程机制\n15\n\n--- 第16页 ---\n信号量机制\n16\n1965年，荷兰学者 Dijkstra\n提出了信号灯机制，卓有\n成效地解决了进程同步问\n题。\n荷兰科学家， 1972年图灵\n奖获得者 。\n\n--- 第17页 ---\n信号量\n整型信号量\n记录型信号量\nAND型信号量\n信号量集\n17一类资源抽象成S（信号量）\n●信号量与一般 变量不同，必须初始化，而且只能\n两个标准 wait(S)/ P、signal(S)/ V原子操作来访问。",
      "chunk_index": 2
    },
    {
      "text": "V原子操作来访问。\n\n --- 第18页 ---\n整型信号量\n18一类资源抽象成S（信号量）\nwait(S){\nwhile(S<=0)    ;\nS\n--\n;\n}\nsignal(S){\nS++;\n}●整型信号量定义为一个 用于表示资源数目的整型量 S。\nS>0\n时，表示还有\n S\n个资源可用\nS\n<=0\n，\n表示没有可用的资源\n●缺点：不遵循“让权等待”，忙 等\n\n--- 第19页 ---\n记录型信号量\n记录型信号量\n٭信号量S：记录型数据结构 ,一个分量为整型量 value,另\n一个分量为信号量队列 L；\n信号量的物理含义\n٭当S.value >0：表示可用资源个数\n٭当S.value＝0：表示可用资源正好用完\n٭当S.value <0：表示等待该类资源的进程数\n19一类资源抽象成S（信号量）\nvalue0\nL=nil\n信号量的值 (-2)\n信号量队列指针\n\n--- 第20页 ---\n思考题\n若P、V操作的信号量 S初值为 2，当前值为\n－1，则表示有 等待进程。\nA．0个\nB．1个\nC．2个\nD．3个\n20\n\n--- 第21页 ---\n思考题\n若P、V操作的信号量 S初值为 2，当前值为\n－1，则表示有 等待进程。\nA．0个\nB．1个\nC．2个\nD．3个\n21\n\n--- 第22页 ---\n记录型信号量描述\n22typedef struct\n{intvalue ;\nstruct process_control_block *L;\n}semaphore ;\n\n--- 第23页 ---\nwait(semaphore *S)\n{\nS.value =S.value –1; /*把信号量减去 1*/\nifS.value <0then block(S .L);\n/*若信号量小于 0，则调用 wait(S)的进程被\n置成等待信号量 S的状态 */\n}\n物理意义： 申请一个资源 ，如果申请成功 ，则\n返回；如果申请不成功 ，则挂在该资源的\n等待队列上 。\n记录型信号量描述",
      "chunk_index": 3
    },
    {
      "text": "。\n记录型信号量描述\n\n --- 第24页 ---\nsignal(semaphore *S)\n{\nS.value =S.value +1; /*把信号量加 1*/\nifS.value <=0then wakeup(S .L);\n/*若信号量小于等于 0，则释放一个等待信\n号量 s的进程 */\n}\n物理意义 ：归还一个资源 ，如果没有进程等待该资\n源，则返回；如果有进程在等待 ，把等待\n的进程从 L上移到就绪队列 。\n记录型信号量描述\n\n--- 第25页 ---\n用Signal操作唤醒一个等待进程时，被唤\n醒进程的状态变为 ．\nA．等待\nB．就绪\nC．运行\nD．完成\n思考题\n\n--- 第26页 ---\n用Signal操作唤醒一个等待进程时，被唤\n醒进程的状态变为 ．\nA．等待\nB．就绪\nC．运行\nD．完成\n思考题\n\n--- 第27页 ---\n信号量及\n wait\n、\nsignal\n操作讨论\n (1)\n信号量的物理含义：\n٭S .value >0: 表示有 S .value个资源可用\n٭S .value =0: 表示无资源可用\n٭S .value <0: 则| S .value| 表示等待队列中的进程个数\n信号量的初值应该大于等于 0\n27\n\n--- 第28页 ---\nWait\n、\nsignal\n操作讨论\n (2)\nwait(S)：表示申请一个资源\nsignal(S)：表示释放一个资源。\nwait、signal操作必须成对出现，有一个 wait操作\n就一定有一个 signal操作\nwait、signal操作的优点\n简单，而且表达能力强，可解决任何互斥问题\nwait、signal操作的缺点\n不够安全， wait、signal操作使用不当会出现死锁，遇到复\n杂互斥问题时，实现复杂。\n28\n\n--- 第29页 ---\n利用记录型信号量实现进程互斥\n目标：\n٭临界资源的互斥访问\n٭临界区的互斥进入\n信号量\n如何通过对信号量的操作实现上述目标呢\n٭wait(P操作 )\n٭signal(V操作 )\n\n--- 第30页 ---\n利用记录型信号量实现进程互斥\n30\nwait(mutex)\nsignal(mutex)\nP1\n P2\n临界区wait(mutex)\nsignal(mutex)mutex.value =1",
      "chunk_index": 4
    },
    {
      "text": "=1\n\n --- 第31页 ---\n用\nwait\n、\nsignal\n操作实现互斥\n (p61)\n信号量初值为 1\n对于两个并发进程，互斥信号量的值仅取 1、0和-1三个值\n٭若mutex.value ＝1表示没有进程进入临界区\n٭若mutex.value ＝0表示有一个进程进入临界区\n٭若mutex.value ＝-1表示一个进程进入临界区，另一个进\n程等待进入。\n对于 n个并发进程， 互斥信号量的取值范围是？\n31\n\n--- 第32页 ---\n思考题\n32对于两个并发进程，设互斥信号量为 mutex，若\nmutex.value =0，则 。\nA．表示没有进程进入临界区\nB．表示有一个进程进入临界区\nC．表示有一个进程进入临界区，另一个进程等待进入\nD．表示有两个进程进入临界区\n\n--- 第33页 ---\n思考题\n33对于两个并发进程，设互斥信号量为 mutex，若\nmutex.value =0，则 。\nA．表示没有进程进入临界区\nB．表示有一个进程进入临界区\nC．表示有一个进程进入临界区，另一个进程等待进入\nD．表示有两个进程进入临界区\n\n--- 第34页 ---\n利用\n wait\n、\nsignal\n操作实现两个进程互斥的模板\n34struct semaphore mutex;\nmutex.value=1;  mutex.L=nil;\ncobegin\nProcess P1:{\nM\nwait (mutex);\n临界区 1\nsignal(mutex);\nM\n} \nProcess P2:{\nM\nwait(mutex);\n临界区 2\nsignal(mutex);\nM\n}\ncoend\n\n--- 第35页 ---\n思考题\n35使用 wait、signal操作实现互斥时，当多个进程要\n互斥地访问一个临界资源，信号量的初值为 。\nA．-1      \nB．0     \nC．1      \nD．2\n\n--- 第36页 ---\n思考题\n36使用 wait、signal操作实现互斥时，当 多个进程要\n互斥地访问一个临界资源，信号量的初值为 。\nA．-1      \nB．0     \nC．1      \nD．2",
      "chunk_index": 5
    },
    {
      "text": "D．2\n\n --- 第37页 ---\n使用\n wait/signal\n 操作实现互斥应注意\n识别临界资源\n是否被共享 ;\n是否有排它性使用要求。\n临界区代码应尽量短小，不能有死循环。\nwait和signal原语应分别紧靠临界区的头尾。\nwait、signal操作在同一进程中必须成对出现。\n37\n\n--- 第38页 ---\n思考题\n用记录型信号量解决二人存款问题，用类 C语言编\n写进程互斥算法。\n38\n\n--- 第39页 ---\n临界资源实例\n二人合作存款\ncount:=100;\nPA  S1:N:=count;\nS2:N:=N+100;\nS3:count:=N;\n39PB  S4:M:=count;\nS5:M:=M+200;\nS6:count:=M;\n\n--- 第40页 ---\n用\nwait\n、\nsignal\n操作实现\n 进程的同步\n只要信号量初值是一个大于等于 0的整数就能达到\n同步的目的，就可以直接使用 wait、signal操作实\n现同步\n互斥是一种特殊的同步\nwait、signal操作既可以实现互斥，也可以实现同步\n42\n\n--- 第41页 ---\n设有三个并发执行的进程 P1、P2、P3，其前趋图如下，试\n用信号量实现这三个进程同步。\n设两个同步信号量 S1、S2分别表示进程 P2、P3能否开始执行\n semaphore S1,S2;\n S1.value=0,S2.vaule=0;        /* 初值均为 0*/\ncobegin\nP1: {signal(S1) ; signal(S2); }\nP2: { wait(S1); ; }\nP3: { wait(S2); ; }\ncoend\n利用信号量实现进程同步的实例\n43P1\nP3P2\n\n--- 第42页 ---\n进程的同步\n一般同步问题有两类\n٭保证一组合作进程按逻辑需要的执行次序执行\n【例】司机 P1 售票员 P2\nREPEAT                 REPEAT\n启动 关门\n正常运行 售票\n到站停 开门\nUNTIL FALSE      UNTIL FALSEclose\nstop",
      "chunk_index": 6
    },
    {
      "text": "FALSEclose\nstop\n\n --- 第43页 ---\n使用\n wait/signal\n 操作实现同步应注意\n信号量的设置\n信号量的初值\nwait/signal 操作要成对出现，并在不同的进\n程中\n47\n\n--- 第44页 ---\n信号量及\n wait\n、\nsignal\n操作讨论\nwait、signal操作必须成对出现，有一个 wait操作就一定有\n一个 signal操作\n当为互斥操作时，它们同处于同一进程\n当为同步操作时，则不在同一进程中出现\n如果 wait(S1)和wait(S2)两个操作在一起，那么 wait操作的\n顺序至关重要。\n一个同步 wait操作与一个互斥 wait操作在一起时 ,同步 wait\n操作在互斥 wait操作前，而两个 signal操作无关紧要。\n48\n\n--- 第45页 ---\nwait/signal\n 操作实现互斥与同步的模板\n进程互斥\nS初值为 1\nP1 P2\nwait(S)         wait(S)\n临界区 1        临界区 2\nsignal(S)      signal(S)\n在P1与P2中设置相同的 wait、signal\n操作进程同步\nS1初值为 n，S2初值为 0\nP1 P2\nwait(S1) wait(S2)\n段1                  段2\nsignal(S2) signal(S1)\n49\n\n--- 第46页 ---\n经典的进程同步\n 问题\n生产者 /消费者问题\n读者 /写者问题\n哲学家进餐问题\n50\n\n--- 第47页 ---\n生产者\n /\n消费者问题\n生产者消费者问题是一种同步问题的抽\n象描述。计算机系统中的每个进程都可以消\n费（使用）或生产（释放）某类资源 。这些\n资源可以是硬件资源 ，也可以是软件资源 。\n当某一进程使用某一资源时 ，可以看作\n是消费，称该进程为消费者 。而当某一进程\n释放某一资源时 ，它就相当于生产者 。\n51\n\n--- 第48页 ---\n生产者\n /\n消费者问题\n (\n描述\n )\n通过一个公用缓冲池可以把一群生产者\nP1,P2…,Pi，和一群消费者 Q1,Q2,…, Qj联系\n起来。如图 :\n只要缓冲区未满，生产者就可以把产品送入\n缓冲区 ;\n只要缓冲区未空，消费者就可以从缓冲区中\n取走物品。\n52",
      "chunk_index": 7
    },
    {
      "text": ";\n只要缓冲区未空，消费者就可以从缓冲区中\n取走物品。\n52\n\n --- 第49页 ---\n生产者\n /\n消费者问题\n (\n图示\n )\n53\n生\n产\n者消\n费\n者\n缓冲池：由若干个存放资源的缓冲区构成\n\n--- 第50页 ---\n54\n\n--- 第51页 ---\n生产者\n /\n消费者必须互斥\n55生产者和消费者不能同时\n访问缓冲池\n否则可能同时读 /写一个\n存储单元\n导致结果不确定。缓冲池是临界资源\n生产者和消费\n者需要互斥\n\n--- 第52页 ---\n生产者\n /\n消费者必须同步\n56只要缓冲区未满，生产者\n就可以把产品送入缓冲区 ;\n只要缓冲区未空，消费者\n就可以从缓冲区中取走产\n品生产者不能向满缓冲\n区放产品\n消费者不能在空缓冲\n区中取产品\n生产者放入产品之后，消费者才\n能去取产品\n消费者取走产品之后，生产者才\n能去放产品生产者和消费\n者需要同步\n\n--- 第53页 ---\n生产者\n /\n消费者必须同步\n57item buffer[N];\nintin, out=0, 0 ;\n生产者进程：\n{\n生产一个产品 item;\n//将产品放入缓冲区\nbuffer[in]=item;\nin\n= (in + 1) % N\n}消费进程：\n{\n//从缓冲区中取走一\n个产品\nitem=buffer[out];\nout=( out+1 )%N\n}取了之后才能放full\nempty放了之后才能取\n\n--- 第54页 ---\n生产者\n /\n消费者必须同步\n问题：\n同步信号量 empty,full 的初始\n值为多少\n因为缓冲池大小为 N，假定\n初始情况下，所有的缓冲区\n都为空，那么\nempty.value =N\nfull.value =0信号量解决同步问题：\n1.如果有有向边指向自己，\nwait\n2.如果有有向边从自己出发，\nsignal",
      "chunk_index": 8
    },
    {
      "text": "=0信号量解决同步问题：\n1.如果有有向边指向自己，\nwait\n2.如果有有向边从自己出发，\nsignal\n\n --- 第55页 ---\n59item buffer[N];\nintin, out=0, 0 ;\nSemaphore empty,full ;\nEmpty.value =N,full.value =0\n生产者进程：\n{\n生产一个产品 item;\n//将产品放入缓冲区\nbuffer[in]=item;\nin\n= (in + 1) % N\n}消费进程：\n{\n//从缓冲区中取走一\n个产品\nitem=buffer[out];\nout=(out+1)% N\n}full\nemptywait(empty)\nsignal(empty) signal(full)wait(full)\n\n--- 第56页 ---\n60item buffer[N];\nintin, out=0, 0 ;\nSemaphore empty , full, mutex ;\nempty.value =N, full.value =0, mutex.value =1\n生产者进程：\n{\n生产一个产品 item;\n//将产品放入缓冲区\nbuffer[in]=item;\nin\n= (in + 1) % N\n}消费进程：\n{\n//从缓冲区中取走一\n个产品\nitem=buffer[out];\nout=(out+1)% N\n}empywait(empty)\nsignal(empty) signal(full)wait(full)\nwait(mutex)wait(mutex)\nsignal(mutex) signal(mutex)",
      "chunk_index": 9
    },
    {
      "text": "signal(mutex)\n\n --- 第57页 ---\n61item buffer[N];\nintin, out=0, 0 ;\nSemaphore empty , full, mutex ;\nempty.value =N, full.value =0, mutex.value =1\n生产者进程：\n{\n生产一个产品 item;\n//将产品放入缓冲区\nbuffer[in]=item;\nin\n= (in + 1) % N\n}消费进程：\n{\n//从缓冲区中取走一\n个产品\nitem=buffer[out];\nout=(out+1)% N\n}empywait(empty)\nsignal(empty) signal(full)wait(full)\nwait(mutex)wait(mutex)\nsignal(mutex) signal(mutex)wait的顺序\n能否交换 wait的顺序\n能否交换\n\n--- 第58页 ---\n62item buffer[N];\nintin, out=0, 0 ;\nSemaphore empty , full, mutex ;\nempty.value =N, full.value =0, mutex.value =1\n生产者进程：\n{\n生产一个产品 item;\n//将产品放入缓冲区\nbuffer[in]=item;\nin\n= (in + 1) % N\n}消费进程：\n{\n//从缓冲区中取走一\n个产品\nitem=buffer[out];\nout=(out+1)% N\n}wait(empty)\nsignal(empty) signal(full)wait(full)\nwait(mutex)wait(mutex)\nsignal(mutex) signal(mutex)signal的顺序\n能否交换signal的顺序\n能否交换\n\n--- 第59页 ---\n进程的同步\n一般同步问题有两类\n٭保证共享缓冲区（共享数据）的合作进程的同步\n【例】\n输入\n进程 PI缓冲区 缓冲区计算\n进程 PC打印\n进程 PP",
      "chunk_index": 10
    },
    {
      "text": "PP\n\n --- 第60页 ---\n【\n2014\n年计算机联考真题\n 】\n系统中有多个生产者和多个消费者进程，共享一个能存放\n 1000\n件产品的环形缓冲区（初始为空）。当缓冲区未满时，生产者\n进程可以放入其生产的一件产品，否则等待；当缓冲区为满时\n，消费者进程可以从缓冲区取走一件产品，否则等待。\n要求一个消费者进程从缓冲区连续取出\n 10\n件产品后，其他消费\n者进程才可以取产品。\n请添加必要的信号量和\n PV\n（或者\n wait\n和\nsignal\n）操作，实现\n上述进程的互斥和同步。要求写出完整的过程，说明信号\n量的含义并赋初值。\n思考题\n\n--- 第61页 ---\nsemaphore mutex1=1;\n//\n控制一个消费者进程一个周期内对缓冲区的控制，初值为\n 1\nsemaphore mutex2=1;   \n //\n进程单次互斥访问缓冲区，初值为\n 1\nsemaphore full=0;\n //\n满缓冲区的数量，初始为\n 0\nsemaphore empty=1000;\n //\n空缓冲区的数量，初始为\n 1000\nvoid\n prodecer\n () {\nwhile\n (1) {\nproduce an item in \n nextp\n ;\n...\nwait(empty);\nwait(mutex2);\nput the product in buffer\nsignal(mutex2);\nsignal(full);\n}\n}\nvoid\n consumer() {\nwhile\n (1) {\nwait(mutex1)\nfor(\nint\ni\n=0;i<10;i++){\nwait(full);\nwait(mutex2);\nget the product from buffer\nsignal(mutex2);\nsignal(empty);\nconsumer this product\n}\nsignal(mutex1);\n}\n}",
      "chunk_index": 11
    },
    {
      "text": "product\n}\nsignal(mutex1);\n}\n}\n\n --- 第62页 ---\n例子\n某工厂有两个生产车间和一个装配车间。\n 两个生产车间\n分别生产\n A\n、\nB\n两种零件，装配车间的任务是把\n A\n、\nB\n两\n种零件组装成产品。\n 两个生产车间每生产一个零件后都\n要分别把它们送到装配车间的货架\n F1\n、\nF2\n上。\n F1\n存放零\n件\nA\n，\nF2\n存放零件\n B\n，\nF1\n和\nF2\n的容量均可以存放\n 10\n个零\n件。\n装配工人每次从货架上取一个零件\n A\n和一个零件\n B\n后\n组装成产品。\n请用\n wait\n、\nsignal\n操作进行正确管理。\n\n--- 第63页 ---\n本题是生产者\n -\n消费者问题的变形\n\n生产者“车间\n A\n”和消费者“装配车间”共享缓\n冲\n区“货架\n F1\n”\n\n生产者“车间\n B\n”和消费者“装配车间”共享缓\n冲区“货架\n F2\n”\n\n每个货架的容量均为\n 10\n\n可以设置\n 6\n个信号量：\n\nemptyA\n /\nemptyB\n对应\n货架\n F1/F2\n上的空闲空间\n\nfullA\n /\nfullB\n对应\n货架\n F1/F2\n上的\n A/B\n产品\n\nmutexA\n用于\n互斥访问货架\n F1\n\nmutexB\n用于\n互斥访问货架\n F2\n缓冲区属于临界资源，所以需要\n资源信号量和互斥信号量\n初值为\n 10\n初值为\n 0\n初值为\n 1",
      "chunk_index": 12
    },
    {
      "text": "1\n\n --- 第64页 ---\nsemaphore  \n mutexA\n = \nmutexB\n = 1;  \nsemaphore  \n emptyA\n = \nemptyB\n = 10;\nsemaphore  \n fullA\n = \nfullB\n = 0;\nA\n车间的工作过程可描述为：\nvoid\n workshopA\n () {\nwhile \n (1) {\nproduce an product A;\nwait(\n empyA\n );\nwait(\n mutexA\n );\nput product A on shelf F1\nsignal(\n mutexA\n );\nsignal(\n fullA\n );\n}\n}\nB\n车间的工作过程可描述为：\nvoid\n workshopB\n () {\nwhile \n (1) {\nproduce an product B;\nwait(\n empyB\n );\nwait(\n mutexB\n );\nput product B on shelf F2\nsignal(\n mutexB\n );\nsignal(\n fullB\n );\n}\n}\n装配车间\n 的工作过程可描述为：\nvoid\n Fittingshop\n () {\nwhile \n (1) {\nwait(\n fullA\n );\nwait(\n mutexA\n );\nget product A from shelf F1\nsignal(\n mutexA\n );\nsignal(\n empyA\n );\nwait(\n fullB\n );\nwait(\n mutexB\n );\nget product B from shelf F2\nsignal(\n mutexB\n );\nsignal(\n empyB\n );\nAssemble the product A and B  \ninto products\n}\n}",
      "chunk_index": 13
    },
    {
      "text": "products\n}\n}\n\n --- 第65页 ---\n例子\n【\n2009\n年计算机联考真题\n 】\n三个进程\n P1/P2/P3\n 互斥使用一个包含\n N\n（\nN>0\n）个单元的缓冲区。\nP1\n：\n每次用\n producer()\n 生成一个正整数并用\n put()\n送入缓冲区某一空单\n元中；\nP2\n：\n每次用\n getodd\n ()\n从该缓冲区中取出一个奇数并用\n countodd\n ()\n统计奇\n数个数；\nP3\n：\n每次用\n geteven\n ()\n从缓冲区中取出一个偶数并用\n counteven\n ()\n统计偶\n数个数。\n请用信号量机制实现三个进程的同步与互斥活动，并说明所定义的信\n号量的含义（要求用伪代码描述）。互斥信号量 mutex=1\n资源信号量 empty=N\nP1/P2\n因为奇数的放置与取用而同步，设置\n 同步信号量\n odd=0\n；\nP1/P3\n因为偶数的放置与取用而同步，设置\n 同步信号量\n even=0\n；\n\n--- 第66页 ---\n本题是生产者\n -\n消费者问题的变形\n\nP1/P2/P3\n 共享缓冲区，大小为\n N\n\nP1/P2\n因为奇数的放置与取用而同步\n\nP1/P3\n因为偶数的放置与取用而同步\n\n缓冲区只能互斥访问\n\n可以设置\n 4\n个信号量：\n\nempty\n对应空缓冲区单元个数\n\nmutex\n用于互斥访问缓冲区\n\nodd/even\n 用于同步\n P1/P2\n和\nP1/P3\n初值为\n N\n初值为\n 1\n初值为\n 0\n例子",
      "chunk_index": 14
    },
    {
      "text": "0\n例子\n\n --- 第67页 ---\nsemaphore  mutex = 1;  \nsemaphore  empty = N;\nsemaphore  odd = even = 0;\nP1\n可以描述为：\nvoid\n P1() {\nwhile \n (1) {\nx=produce();\nwait(empty);\nwait(mutex);\nput()\nsignal(mutex);\nif(x%2==0)\nsignal(even);\nelse\nsignal(odd);\n}\n}\nP2\n可描述为：\nvoid\n P2() {\nwhile \n (1) {\nwait(odd);\nwait(mutex);\ngetodd\n ();\nsignal(mutex);\nsignal(empty);\ncountodd\n ();\n}\n}\nP3\n可描述为：\nvoid\n P3() {\nwhile \n (1) {\nwait(even);\nwait(mutex);\ngeteven\n ();\nsignal(mutex);\nsignal(empty);\ncounteven\n ();\n}\n}\n例子\n\n--- 第68页 ---\n读者\n /\n写者问题\n有两组并发进程 : \n٭读者和写者 ,共享一个数据文件\n要求：\n٭允许多个读者同时执行读操作\n٭不允许读者、写者同时操作\n٭不允许多个写者同时操作\n76\n\n--- 第69页 ---\n读者\n /\n写者问题\n如果读者来：\n1.有其他读者么，有，直接读。\n2.没有其他读者，有写者么，没有，上锁，开始读\n3.有写者，等 。\n如果写者来：\n1.有其他进程么，没有，上锁，开始写。\n2.有其他进程，等。\n77\n\n--- 第70页 ---\n读者\n /\n写者问题\n读者结束：\n1.自己是最后一个读进程么，不是，直接离开\n2.自己是最后一个读进程，开锁，离开 。\n写者结束：\n开锁，离开。\n78",
      "chunk_index": 15
    },
    {
      "text": "。\n写者结束：\n开锁，离开。\n78\n\n --- 第71页 ---\n读者写者问题的解法\n为实现读者和写者、写者和写者之间的互斥，设置一个互斥\n信号量 Wmutex =1\n由于“读 —读”允许，再设置一个整型变量 Readcount 表示\n正在读的进程数，初值 Readcount =0\n由于 Readcount 是一个可被多个读者进程访问的临界资源 ，\n所以要为它设置一个互斥信号量 Rmutex =1\n读者 —写者算法如下：\n79读者：\ndo{\nwait(Rmutex);\nif readcount=0 then wait(Wmutex) ;\nReadcount:= Readcount+1;\nsignal(Rmutex) ;\n读\nwait(Rmutex) ;\nReadcount:= Readcount -1;\nif Readcount=0 then signal(Wmutex) ;\nsignal(Rmutex) ;\n}while(true)写者：\ndo{\nwait(Wmutex);\n写\nsignal(Wmutex) ;\n}while(true)\n\n--- 第72页 ---\n独木桥问题。某条河上只有一座独木桥，以便行人过河。\n现在河的两边都有人要过桥，按照下面的规则过桥。为了\n保证过桥安全，请用\n P\n、\nV\n（或者\n wait\n和\nsignal\n）操作分别\n实现正确的管理。\n过桥的规则是：同一方向的可连续过桥，某方向有人过桥\n时另一方向的人要等待。\n思考题\n\n--- 第73页 ---\n思路分析\n1.\n关系分析。\n将独木桥的两个方向分别标记为\n A\n和\nB\n。由题目分析可知\n A\n和\nB\n是相互互斥\n的，并且使用独木桥的过程应该也是排外的。\n2.\n整理思路。\n两个进程，即\n A\n方向行人过桥和\n B\n方向行人过桥。\n两个进程类似，只有在对方方向上没有行人时，才能过桥，并且过桥时\n一定是不允许另一个方向行人过桥。\n3.\n设置信号量。\n两个整型变量\n countA\n和\ncountB\n：分别表示\n A\n，\nB\n方向上已在独木桥上的行人\n数，初值为\n 0\n互斥信号量\n SA/SB\n：分别用于实现对另一个方向的行人互斥，或者说保护\ncountA\n和\ncountB\n修改时的排外性，初值为\n 1\n互斥信号量\n mutex\n：用于实现对独木桥的互斥使用，初值为\n 1",
      "chunk_index": 16
    },
    {
      "text": "1\n\n --- 第74页 ---\nint\ncountA\n =\ncountB\n =0; \n//\n分别表示\n A/B\n方向上已在独木桥上的行人数\nsemaphore \n mutex\n =1;\n //\n实现对独木桥的互斥使用，初值为\n 1\nsemaphore \n SA=SB=1\n ;  \n//\n分别实现对\n countA\n /\ncountB\n的互斥访问，初值为\n 1\nA\n方向行人过桥\nvoid\n DirectionA\n () {\nwhile\n (1) {\nwait(SA);\nif(\ncountA\n ==0)\nwait(\n mutex\n );\ncounA\n ++;\nsignal(SA);\n过桥\nwait(SA);\ncounA\n --\n;\nif(\ncountA\n ==0)\nsignal(\n mutex\n );\nsignal(SA);\n}\n}\nB\n方向行人过桥\nvoid\n DirectionB\n () {\nwhile\n (1) {\nwait(SB);\nif(\ncountB\n ==0)\nwait(\n mutex\n );\ncounB\n ++;\nsignal(SB);\n过桥\nwait(SB);\ncounB\n --\n;\nif(\ncountB\n ==0)\nsignal(\n mutex\n );\nsignal(SB);\n}\n}\n\n--- 第75页 ---\n哲学家就餐问题\n有五个哲学家围坐在一圆桌旁，\n桌中央有一盘通心粉，每人面前\n有一只空盘子，每两人之间放一\n只筷子\n每个哲学家的行为是思考，感到\n饥饿，取筷子，然后吃通心粉，\n放筷子，思考。\n为了吃通心粉，每个哲学家必须\n拿到两只筷子，并且每个人只能\n直接从自己的左边或右边去取筷\n子\n筷子是临界资源，要用 5个互斥\n信号量来表示这 5只筷子。\n83",
      "chunk_index": 17
    },
    {
      "text": "5只筷子。\n83\n\n --- 第76页 ---\n哲学家就餐问题解\n设fork[5]为5 个信号量，初值均为 1\nvarfork:array[ 0,…,4]ofsemaphore ;\nfork[i]= 1;\nPhilosopher_i ：\ndo{\n思考；\nwait(fork[i]); \nwait(fork[(i+1) mod 5]) ；\neat；\nsignal(fork[i]); \nsignal(fork[(i+1) mod 5]) ；\n}while(true)\n84以上解法会出现死锁 ,为防止死锁发生可采\n取的措施：\n最多允许 4个哲学家同时坐在桌子周围\n给所有哲学家编号，奇数号的哲学家必须首\n先拿左边的筷子，偶数号的哲学家则反\n仅当一个哲学家左右两边的筷子都可用\n时，才允许他拿筷子（ ）\n\n--- 第77页 ---\n思考题\n（2019）( 8 分) 有n ( n≥3 ) 位哲学家围坐在一张\n圆桌边，每位哲学家交替地就餐和思考。在圆桌中心有 m ( \nm≥1 ) 个碗，每两位哲学家之间有 1 根筷子。每位哲学\n家必须取到一个碗和两侧的筷子之后，才能就餐，进餐完毕\n，将碗和筷子放回原位，并继续思考。 为使尽可能多的哲学\n家同时就餐，且防止出现死锁现象， 请使用信号量的 P 、\nV 操作( wait () 、signal () 操作) 描述上述过程中\n的互斥与同步，并说明所用信号量及初值的含义。\n87\n\n--- 第78页 ---\n思考\nSemaphore fork[n]={ 1,1,1…1};\nsemaphore bowl=min{n -1,m}\nPhilosopher_i ：\ndo{\n思考；\nwait(bowl)\nwait(fork[i]); \nwait(fork[(i+1) mod n]) ；\neat；\nsignal(fork[i]); \nsignal(fork[(i+1) mod n]) ；\nsignal(bowl)\n}while(true)\n88\n\n--- 第79页 ---\n小结\n掌握进程之间的制约关系\n掌握临界资源、临界区的概念\n掌握临界区的访问原则\n掌握记录型信号量 ,wait和signal\n掌握利用 wait和signal解决进程同步问题\n89",
      "chunk_index": 18
    }
  ]
}