{
  "original_filename": "1746977386_第2章-进程的描述与控制.pdf",
  "processed_at": "2025-05-11T23:29:48.116894",
  "chunks": [
    {
      "text": "--- 第1页 ---\nLecture 1. page 1\n第\n2\n章\n进程的描述与控制\n2.1  前趋图和程序执行\n2.2  进程的描述\n2.3  进程控制\n2.4  进程通信\n2.5  线程的概念\n2.6  线程的实现\n\n--- 第2页 ---\n前趋图\n为了能更好地描述程序的顺序和并发执行情况，我们先\n介绍用于描述程序执行先后顺序的前趋图 。\n所谓前趋图 (Precedence Graph) ，是指一个有向 无环图，\n可记为 DAG（Directed Acyclic Graph ），它用于描述进\n程之间执行的先后顺序 。\n结点表示一个进程 /程序段 /一条语句。\n有向边表示两个结点之间存在的偏序或者前趋 关系。\n前趋图中不允\n许有环\n\n--- 第3页 ---\nLecture 1. page 4\n程序顺序执行示例\n程序的顺序执行\n语句的顺序执行I1C1P1I2C2P2\nS1：a=x+y\nS2：b=a-5\nS3：c=b+1S1S2S3\n特点♪顺序性：处理机的操作严格按规定顺序执行\n♪封闭性：程序执行时，独占系统资源\n♪可再现性 ：当初始条件相同时，程序多次执行\n的结果相同\n\n--- 第4页 ---\nLecture 1. page 7\n程序并发执行示例\n在系统中有 3个程序，每个程序都有三个处理步骤 ，\n输入数据 、处理、输出，即Ii,Ci,Pi(i=1,2,3)。\n这些程序在系统中执行时是对时间的偏序 ，有些操\n作必须在其它操作之前执行 ，这是有序的 ，但有些操作\n是可以同时执行的 。例如:I1、C1、P1的执行必须严格\n按照I1，C1，P1的顺序，而P1与I2，C1与I2，I3与P1是\n可以同时执行的 。\nI1 I2 I3\nC1 C2 C3\nP1 P2 P3\n若每个操作执行时间是 1分钟，则顺序执行需 9分钟，并发执行需 5\n分钟",
      "chunk_index": 0
    },
    {
      "text": "5\n分钟\n\n --- 第5页 ---\nLecture 1. page 8\n程序并发执行时的\n 特征\n间断性\n在并发环境下程序的执行是间断性的：\n执行 ——暂停——执行\n失去封闭性\n由于并发程序共享系统中的资源 ，因而这些资源\n的状态可以由多个程序来改变 ，程序在执行的过程中\n必然会受到其他 程序的影响\n程序结果的不可再现性\n程序经过多次执行后 ，虽然它们执行时的环境和\n初始条件相同 ，但得到的结果却各不相同 。\n的影响。\n\n--- 第6页 ---\nLecture 1. page 9\n程序的并发执行不可再现性举例\ncount=100 ;\nPA  S1:N=count;\nS2:N=N+100;\nS3:count=N ;PB  S4:M=count;\nS5:M=M+200;\nS6:count=M;\n执行情况：\n（1）PA—> PB ,PB—> PA         count=400 √\n（2）S1—> PB—>S2—>S3        count=200 ×\n（3）S4—> PA—>S5—>S6        count=300 ×\n\n--- 第7页 ---\nLecture 1. page 10\n进程的引入\n在多道程序设计的环境下 ，为了能使程\n序并发执行 ，并且可以对并发执行的程序\n加以描述和控制 ，描述系统内部各程序的\n活动规律 ，必须引人新的概念 ——进程。\n\n--- 第8页 ---\nLecture 1. page 11\n实例\nC语\n言编\n译程\n序a.c\n源\n程\n序b.c\n源\n程\n序\n\n--- 第9页 ---\nLecture 1. page 13\n进程的\n定义\n进程是具有独立功能的程序关于某个数据集合上\n的一次运行 活动\n٭进程实体是由 程序段、数据段及进程控制 块PCB\n（Process Control Block），三个部分组成\n进程是系统进行 资源分配和调度 的一个独立单位 。\n\n--- 第10页 ---\nLecture 1. page 15\n进程同程序的比较\n程序\n 进程\n是静态的，是一组代码的集合\n 是动态的，有生命周期\n有生命周期，暂时的\n 没有生命周期，存在是永久的\n进程\n =\n程序\n +\n数据\n +PCB\n一个程序可以对应多个进程\n一个进程只能对应一个程序",
      "chunk_index": 1
    },
    {
      "text": "+PCB\n一个程序可以对应多个进程\n一个进程只能对应一个程序\n\n --- 第11页 ---\nLecture 1. page 17\n进程的\n特征\n结构特征\n٭进程实体是由 程序段、数据段及进程控制块 三个\n部分组成\n动态性\n٭生命周期及“执行” 本质\n并发性\n٭指多个进程实体同时存在于内存中，能在一段时\n间内同时运行（并发）。\n独立性\n٭进程是一个运行的独立单位\n٭系统资源分配和保护的独立单位。\n异步性\n٭进程以各自独立的、不可预知的速度向前推进。\n\n--- 第12页 ---\nLecture 1. page 18\n进程\n的基本状态及转换\n实例\n假设内存中有 3个进程 A、B、C，若A、C两\n进程需要执行 12条指令，B进程需要执行 10条指\n令，且B进程执行到第 4条指令处必须等待 I/O，\n如何跟踪它们的执行过程 ？\n\n--- 第13页 ---\nLecture 1. page 19\n调度算法\n1、进程 A处于什么状态\n2、进程 B处于什么状态\n3、这两种不执行状态是否一样\n\n--- 第14页 ---\nLecture 1. page 20\n进程\n的基本状态及转换\n实例\n假设内存中有 3个进程 Pa、Pb、Pc，若Pa、\nPc两进程需要执行 12条指令，Pb进程需要执行 10\n条指令，且Pb进程执行到第 4条指令处必须等待\nI/O，如何跟踪它们的执行过程 ？\nPa\nPb\nPc内存\n调度程序CPU使用情况\nPa\n6条指令Pb\n4条指令Pc\n6条指令Pa\n6条指令Pc\n6条指令Pb\n6条指令运行状态\nPa\n等待CPU\n就绪状态Pb\n等待I/O\n阻塞状态\n\n--- 第15页 ---\nLecture 1. page 21\n进程的三种基本状态\n就绪状态 （Ready）\n一个进程已经具备运行条件，但由于无 CPU暂时不\n能运行的状态（当调度给其 CPU时，立即可以运行）。\n运行状态 （Running）\n进程占有 CPU，并在CPU上运行。\n阻塞状态（ Wait / Blocked ）\n指进程因等待某种事件的发生而暂时不能运行的状\n态。（即使 CPU空闲，该进程也不可运行）\n\n--- 第16页 ---\n运行\n阻塞 就绪1 3\n2\n4进程调度\n时间片用完等待消息或\nI/O完成\n等待的事件\n已发生\n进程三状态的转换模型",
      "chunk_index": 2
    },
    {
      "text": "3\n2\n4进程调度\n时间片用完等待消息或\nI/O完成\n等待的事件\n已发生\n进程三状态的转换模型\n\n --- 第17页 ---\n思考题\n如果单CPU系统中有 N个进程，运行状态的进程最\n多几个，最少几个 ？就绪状态的进程最多几个 ，\n最少几个 ？阻塞状态的进程最多几个 ，最少几个 ？\n有没有这样的状态转换\n阻塞运行，就绪阻塞。\n就绪队列非空 的情况下，一个状态转换的发生，\n是否一定导致另一个状态转换发生，列出所有的\n可能。\n没有\n1\n、\n执行\n\n阻塞\n导致\n就绪\n\n执行\n2\n、\n执行\n\n就绪\n导致\n就绪\n\n执行\n1\n 0\n 𝑁−1\n0\n 𝑁\n 0\n不一定\n\n--- 第18页 ---\n思考题\n如果单CPU系统中有10个进程\n运行状态的进程 最多（）个，最少（）个\n就绪状态的进程 最多（）个，最少（）个\n阻塞状态的进程 最多（）个，最少（）个\n1\n 0\n0\n0\n9\n10\n\n--- 第19页 ---\n思考题\n如果两个CPU系统中有10个进程\n运行状态的进程 最多（）个，最少（）个\n就绪状态的进程 最多（）个，最少（）个\n阻塞状态的进程 最多（）个，最少（）个\n2\n 0\n0\n0\n8\n10\n\n--- 第20页 ---\n（2014）一个进程的读磁盘操作完成后 ，操作系统针\n对该进程必做的是\nA.修改进程状态为就绪态\nB.降低进程优先级\nC.给进程分配用户内存空间\nD.增加进程时间片大小\n思考题\n\n--- 第21页 ---\n（2014）一个进程的读磁盘操作完成后 ，操作系统针\n对该进程必做的是\nA.修改进程状态为就绪态\nB.降低进程优先级\nC.给进程分配用户内存空间\nD.增加进程时间片大小\n思考题\n\n--- 第22页 ---\n进程五状态的转换模型\n运行\n阻塞 就绪1 3\n2\n4进程调度\n时间片用完等待消息或\nI/O完成\n等待的事件\n已发生创建终止\n进程已经创建，但\n未被\n OS\n接纳为可\n执行进程\n因停止或取消，\n被\nOS\n从执行\n状态释放\n\n--- 第23页 ---\n由于进程的不断创建，系统资源已不能满\n足进程运行的要求，就必须把某些进程挂起\n（suspend），对换到磁盘镜像区中，暂时不\n参与进程调度，起到平滑系统操作负荷的目的。\n（1）终端用户的请求\n（2）父进程的请求\n（3）负荷调节的需要\n（4）操作系统的需要\n进程为何有“挂起”状态",
      "chunk_index": 3
    },
    {
      "text": "经创建，但\n未被\n OS\n接纳为可\n执行进程\n因停止或取消，\n被\nOS\n从执行\n状态释放\n\n--- 第23页 ---\n由于进程的不断创建，系统资源已不能满\n足进程运行的要求，就必须把某些进程挂起\n（suspend），对换到磁盘镜像区中，暂时不\n参与进程调度，起到平滑系统操作负荷的目的。\n（1）终端用户的请求\n（2）父进程的请求\n（3）负荷调节的需要\n（4）操作系统的需要\n进程为何有“挂起”状态\n\n --- 第24页 ---\n挂起就绪态 （readysuspend）\n也称为静止就绪状态 ，表明进程具备运行条件但\n目前在二级存储器中 ，当它被对换到主存才能被调度\n执行。\n挂起阻塞态 （blocked suspend）\n也称为静止阻塞状态 ，表明进程正在等待某一个\n事件且在二级存储器中 。\n新增加的状态\n\n--- 第25页 ---\n具有挂起功能的进程状态及其转换\n挂起等待事件结束\n出现等\n待事件激活挂起\n落选选中运行态\n就绪态\n等待事件结束终止态新建态挂起就\n绪态\n激活挂起挂起阻塞\n态\n阻塞态提交\n提交\n\n--- 第26页 ---\n挂起进程具有如下特征\n该进程不能立即被执行 。\n挂起进程可能会等待事件 ，但所等待事件是独立\n于挂起条件的 ，事件结束并不能导致进程具备执\n行条件。\n进程进入挂起状态是由于 操作系统 、父进程或进\n程本身阻止它的运行 。\n结束进程挂起状态的命令只能通过 操作系统或父\n进程发出。\n\n--- 第27页 ---\nLecture 1. page 37\n进程的实体\n在操作系统中，一个进程是通过其物理实体被感\n知的，进程的物理实体又称为进程的静态描述。进\n程的静态描述由三部分组成：\n程序：描述了进程所要完成的功能；\n数据：进程运行所需要的数据和工作区；\n进程控制块 (PCB)：它包含了进程的描述信息、\n控制信息和资源信息，是进程动态特性的集中反\n映，是进程存在的唯一标志；\n\n--- 第28页 ---\nLecture 1. page 38\n进程\n控制块（\n PCB\n）\nPCB是一个\n数据结构 ，记录了进程的全部信息 .\n进程与 PCB一一对应\n当系统或父进程创建一个进程时，就为它建立了\n一个 PCB；进程结束时又回收其 PCB，进程也随之消\n亡。",
      "chunk_index": 4
    },
    {
      "text": "PCB，进程也随之消\n亡。\n\n --- 第29页 ---\n进程\n控制块（\n PCB\n）的作用\n作为独立运行基本单位的标志（ 是进程存在的唯一\n标志）\n能实现间断性运行方式（ 能刻画出进程的动态\n特征）\n提供进程管理所需要的信息\n٭了解进程所需资源\n٭程序段和数据段起始地址指针\n提供进程调度所需要的信息\n٭是否是就绪进程\n٭进程优先级\n实现其他进程的同步与通信\n\n--- 第30页 ---\nLecture 1. page 40\nPCB\n中的信息（\n 1\n）\n进程标识符\n☼外部标识符 —进程名，通常基于可执行文件名（不唯一）\n☼内部标识符 —进程标识符 (process ID )，唯一，通常是一个整数\n\n--- 第31页 ---\nLecture 1. page 41\nPCB\n中的信息\n （\n2\n）\n处理机状态信息\n☼通用寄存器\n☼指令计数器\n☼程序状态字寄存器\n☼用户栈指针\n也称为处理机的上下文，主要是由处理机的各种寄\n存器中的内容组成\n用户可视寄存器，是用户程序可以访\n问的，用于暂存 信息， 8-32\n存放要访问的下一条指令的地址\n指每个用户进程都有一个或者若干个与之相关的系统\n栈，用于存放过程和系统调用参数及调用地址\n含有状态信息，如条件码、执\n行方式、中断屏蔽标志等。\n\n--- 第32页 ---\nLecture 1. page 42\nPCB\n中的信息\n （\n3\n）\n进程调度信息\n☼当前状态\n☼优先级 (priority)\n☼进程调度所需的其他信息\n☼阻塞原因\n进程控制信息\n☼程序和数据的地址\n☼资源清单\n☼运行统计信息（执行时间、页面调度）\n☼进程间同步和 通信\n☼进程的队列 指针",
      "chunk_index": 5
    },
    {
      "text": "指针\n\n --- 第33页 ---\nLecture 1. page 43\nPCB\n的组织方式\n线性方式\n٭将系统中所有的 PCB都组织在一张 线性表中，将该\n表的起始地址存放在内存的一个专用区域中 。\nstruct PCB       //PCB 记录型数据结构\n{\nchar name[9];   // 进程名\nintpriority;  // 权限\nintarrive;  // 到达时间\nintdemand;  // 需要运行时间\nintuse;  //已运行次数\nprocess -state state; // 状态\n}\nPCB job[50 ]\n优点：实现简单、开销小\n缺点：每次查找时都需要扫描整张 表\n\n--- 第34页 ---\nLecture 1. page 44\nPCB\n的组织方式\n链接方式\n通过PCB的链接\n字，将具有相同\n状态的进程的\nPCB分别链接成\n一个队列，不同\n状态对应多个不\n同的链表 。\n优点：动态数据结构，易于插入和删除 ，内存利用率 高\n缺点：遍历困难，不容易查询\n\n--- 第35页 ---\nLecture 1. page 45\nPCB\n的索引组织方式\n索引表\n就绪表首址\n等待队列 1\n等待队列 2PCB 1\nPCB 2\nPCB 3\nPCB 4\nPCB 5\nPCB 6\nPCB 7\n…\nPCB n PCB表 索引方式\n对具有相同状\n态的进程 ，分\n别设置各自的\nPCB索引表，表\n明PCB在PCB表\n中的地址 。各\n索引表在内存\n中的首址记录\n在内存的一些\n专用单元 中。\n优点：提高检索速度，提高系统性能\n缺点：索引需要占用物理空间，需要动态 维护\n\n--- 第36页 ---\nLecture 1. page 46\nPCB\n是进程存在的唯一标志，下列（\n ）不\n属于\n PCB\n。\nA  \n进程\n ID\nB  CPU\n状态\nC  \n堆栈\n指针\nD  \n全局变量\nD\n思考题\n\n--- 第37页 ---\nLecture 1. page 48\n第\n2\n章\n进程的描述与控制\n2.1  前趋图和程序执行\n2.2  进程的描述\n2.3  进程控制\n2.4  进程通信\n2.5  线程的概念\n2.6  线程的实现",
      "chunk_index": 6
    },
    {
      "text": "线程的实现\n\n --- 第38页 ---\nLecture 1. page 49\n进程控制\n概念\n进程控制是进程管理中最基本的功能 ，主要包括 创建新进\n程、终止已经完成的进程 、将因发生异常情况而无法继续\n运行的进程 置于阻塞状态 、负责进程运行中的 状态转换 等。\n进程控制包括\n٭进程创建\n٭进程撤消\n٭进程阻塞\n٭进程唤醒\n٭进程挂起\n٭进程激活\n这些控制和管理功能是由操作系统 内核中的原语来实现的。\n\n--- 第39页 ---\n原语\n内核提供核外调用的 过程或函数 。\n原语是用若干条机器指令编写的 ，用以完成特\n定功能的一段程序 ，在执行过程中不允许中断 。\n用户不能直接使用 ，需通过特殊的系统调用来\n使用原语 。\n操作系统使用系统 原语 (primitive) 控制进程\n状态改变 。\n原语\n\n--- 第40页 ---\n对进程的管理和控制使用 。\nA.指令\nB.原语\nC.信号量\nD.信箱通信\n思考题\n\n--- 第41页 ---\nLecture 1. page 53\n引起\n进程创建的事件\n用户登录\n分时系统中，验证为合法的终端用户登录\n作业调度\n批处理系统中作业调度程序调度到某作业\n提供服务\n运行中的用户程序提出某种请求\n应用请求\n基于应用程序的需要由其自身创建新进程\n由\n系统内核\n 为用户创建\n一个新进程\n由\n用户进程\n 自己\n创建一个新进程\n\n--- 第42页 ---\n【\n2010\n统考真题\n 】下列选项中，导致创建新进程\n的操作是\nI用户成功登陆 II设备分配 III启动程序执行\nA：仅 I和II\nB：仅 II和III\nC：仅 I和III\nD：I，II，III\n思考题\n\n--- 第43页 ---\n【\n2010\n统考真题\n 】下列选项中，导致创建新进程\n的操作是\nI用户成功登陆 II设备分配 III启动程序执行\nA：仅 I和II\nB：仅 II和III\nC：仅 I和III\nD：I，II，III\n思考题\n\n--- 第44页 ---\nLecture 1. page 56\n进程的\n创建\n创建过程\n٭申请空白 PCB\n٭为新进程分配资源\n如：内存\n٭初始化 PCB\n٭将新进程插入就绪队列\n实现\n٭原语： fork（）\n٭CreateProcess （）\n进程不会自生自灭，所\n有的进程只能由系统或\n父进程创建。",
      "chunk_index": 7
    },
    {
      "text": "（）\n进程不会自生自灭，所\n有的进程只能由系统或\n父进程创建。\n\n --- 第45页 ---\nLecture 1. page 57\n思考题\n下面所述步骤中， 不是创建进程所必需的。\nA. 由调度程序为进程分配 CPU\nB. 建立一个进程控制块\nC. 为进程分配 内存\nD. 将进程控制块链入就绪 队列\n【2021统考真题 】下列选项中，操作系统在创建新进程时，\n必须完成的是 （）。\nⅠ  申请空白的 PCB\nⅡ 初始化 PCB\nⅢ 设置进程状态为执行态\nA  Ⅰ B Ⅰ 、Ⅱ C Ⅰ、Ⅲ D Ⅱ、Ⅲ\nB\nA\n\n--- 第46页 ---\nLecture 1. page 58\n引起进程撤消的事件（\n 1\n）\n正常结束\n٭进程运行结束\n٭用户退出登录\n外界干预\n٭操作员或操作系统干预\n٭父进程撤销其子进程\n٭父进程撤销\n٭操作系统终止\n\n--- 第47页 ---\nLecture 1. page 59\n引起进程撤消的事件（\n 2\n）\n异常结束\n٭越界错误；\n٭进程执行了非法指令；\n٭进程在常态下执行了特权指令；\n٭进程申请的内存超过了系统能提供最大量；\n٭进程运行时间超越了分给的最大时间段；\n٭进程等待时间超越了设定的最大等待时间；\n٭算术错误 ，如除零和操作数溢出；\n٭严重的输入输出错误；\n\n--- 第48页 ---\nLecture 1. page 60\n进程的撤消过程\n根据被终止进程的标识符 ，从PCB集合中检\n索出该进程的 PCB；\n若进程正在执行 ，终止进程的执行；\n若该进程拥有子进程 ，应先撤销它的所有子\n孙进程，以防它们脱离控制；\n将进程所拥有的资源交给父进程或系统进程；\n撤销进程出队，将它的 PCB插入到空闲进程\n队列。\n原语： exit（）\n\n--- 第49页 ---\nLecture 1. page 61\n思考题\n通常，用户进程被建立后， 。\nA. 便一直存在于系统中，直到被操作人员 撤消\nB. 随着进程运行正常或不正常结束而撤消\nC. 随着时间片轮转而撤消与 建立\nD. 随着进程的阻塞或唤醒而撤消与建立\nB",
      "chunk_index": 8
    },
    {
      "text": "随着进程的阻塞或唤醒而撤消与建立\nB\n\n --- 第50页 ---\nLecture 1. page 62\n进程的阻塞与唤醒\n引起进程阻塞和唤醒的事件\n٭向系统请求共享资源失败，启动某种操作，新数据尚未到达，\n无新工作可做\n进程阻塞 过程（ block）\n٭停止进程执行 ，保存现场信息到 PCB。\n٭修改PCB的有关内容 ，如进程状态由运行改为阻塞等 。\n٭把修改状态后的 PCB加入相应阻塞进程队列 。\n٭转入进程调度程序 ，从就绪队列中重新调度其他进程运行 .\n自己调用阻塞原语阻塞自己\n进程唤醒 过程（ wakeup）\n٭从相应等待进程队列中取出 PCB。\n٭修改PCB有关信息 ，如进程状态等 。\n٭把修改后 PCB加入有关就绪进程队列 。\n由有关进程调用唤醒原语 来实现，自己不能唤醒自\n己Block原语和\nwakeup原语是一对\n作用刚好相反的原\n语。在使用它们时\n，必须成对使用。\n\n--- 第51页 ---\nLecture 1. page 63\n思考题\n一个进程被唤醒意味着 。\nA. 该进程重新占有了 CPU\nB. 它的优先权变为 最大\nC. 其PCB移至等待队列队 首\nD. 进程变为就绪状态\nD\n\n--- 第52页 ---\n进程的挂起\n由挂起原语 suspend（）实现，执行过程如下：\n把挂起进程的 PCB从相应的队列中移出 ;\n检查要被挂起进程的状态，若处于活动就绪态就修改为挂起就绪，\n若处于阻塞态，则修改为挂起阻塞。\n被挂起的进程要从内存交换到磁盘对换区。\n进程的激活\n由激活原语 active（）实现，其主要工作如下：\n把进程从外存调进内存；\n改变进程状态：静止就绪改为活动就绪，静止阻塞改为活动阻塞。\n把PCB插入相应队列中 .\n说明：挂起原语既可由进程自己也可由其他进程调用，\n但激活原语却只能由其他进程调用。\n进程的激活与挂起\n\n--- 第53页 ---\nLecture 1. page 65\n第\n2\n章\n进程的描述与控制\n2.1  前趋图和程序执行\n2.2  进程的描述\n2.3  进程控制\n2.4  进程通信\n2.5  线程的概念\n2.6  线程的实现",
      "chunk_index": 9
    },
    {
      "text": "线程的实现\n\n --- 第54页 ---\nLecture 1. page 66\n进程通信概述66\n进程通信概念\n指进程之间的信息交换。\n实现机制\n低级进程通信 ：效率低，主要针对控制信息的传递。\n典型实例为信号量机制。\n高级进程通信 ：能传送大量数据，效率高。进程通\n信实现细节由操作系统提供，整个通信过程对用户\n透明，通信程序编制简单。\n\n--- 第55页 ---\nLecture 1. page 67\n进程通信的\n 类型\n共享存储器 (shared memory) 系统\n管道（Pipe）通信系统\n消息传递 (message passing) 系统\n客户机服务器系统67\n\n--- 第56页 ---\n共享存储器系统\n共享内存通信方式的主要思想\n在内存中划出一块共享存储区 ，把需要交换的大量信\n息发送到该存储区中 ，接收进程从\n该区域读取信息 ，从而实现诸进程\n间的通信 。\n这种通信方式需要解决两个问题：\n约定的区域在什么地方\n通信的进程怎样发送信息 ，\n怎样接收信息\n这两个问题可以通过\n创建、附接、断接系统调用 来解决\nProcess A\nProcess BShared memory\nkernel\n\n--- 第57页 ---\n共享内存的实现\nA正文\nA数据\nA栈共享分区B正文\nB数据\nB栈A进程虚空间 B进程虚空间 内存空间\n69\n\n--- 第58页 ---\nLecture 1. page 70\n管道通信系统\n管道（ pipe文件）通信（也称共享文件通信）\n连接读写进程的一个特殊文件，允许进程按先进先出方\n式传送数据 ,也能使进程同步执行操作。\n实质：是一个共享文件，基本上可借助于文件系统的机制\n实现，包括（管道）文件的创建、打开、关闭和读写。\n管道通信\n发送进程以 字符流形式把大量数据送入管道，接收进程\n从管道中接收数据，所以叫管道通信。70\n写进程共享\n文件读进程",
      "chunk_index": 10
    },
    {
      "text": "字符流形式把大量数据送入管道，接收进程\n从管道中接收数据，所以叫管道通信。70\n写进程共享\n文件读进程\n\n --- 第59页 ---\nLecture 1. page 71\n管道通信准则\n互斥\n进程对通信机构的使用应该互斥 ，一个进程正在使用某\n个管道写入或读出数据时 ，另一个进程就必须等待 。\n同步\n当写（输入）进程把一定数量的数据写入 pipe后，便\n去睡眠等待，直到读（输出）进程取走数据将其唤醒；当读\n进程读一空 pipe，也应睡眠等待，直至写进程将数据写入管\n道，才将其唤醒。\n确定对方的存在\n发送者和接收者双方必须能够知道对方是否存在 ，如果\n对方已经不存在 ，就没有必要再发送信息 。71\n\n--- 第60页 ---\nLecture 1. page 72\n消息传递系统\n消息传递机制\n进程间的数据交换以 消息为单位，程序员利用系统的通信原语 （要\n进行消息传递时执行 send；当接收者要接收消息时执行 receive）实\n现通信。这种通信方式属于高级通信 。\n分类\n直接通信 （消息缓冲通信 ）：发送进程直接把消息发送给接收者 ，\n并将它挂在接收进程的消息缓冲队列上 。接收进程从消息缓冲队\n列中取得消息 。\n间接通信 (信箱通信 )：发送进程将消息发送到某种中间实体中\n（信箱），接收进程从中取得消息。\n在网络中称为电子邮件系统。72\n\n--- 第61页 ---\nLecture 1. page 73\n消息传递通信的直接通信\n 方式73\n采用直接通信方式，即发送进程利用 OS所提供的 发送原语 ，\n直接把消息发送给目标进程。\n直接通信原语\n对称寻址方式\n非对称寻址方式\n消息的格式\n进程的同步方式\n通信链路\n单向通信链路\n双向通信链路\n要求发送进程和接收进程都必须\n以\n显式方式\n 提供对方的标识符\n接收进程不需要命名发送进程，\n只需要填写源进程的参数；发送\n进程则仍需要命名接收进程。",
      "chunk_index": 11
    },
    {
      "text": "提供对方的标识符\n接收进程不需要命名发送进程，\n只需要填写源进程的参数；发送\n进程则仍需要命名接收进程。\n\n --- 第62页 ---\nLecture 1. page 74\n消息缓冲通信的\n 实现\n（补充）\n操作系统空间设置一组缓冲区；\n当发送进程需要发送消息时，执行 send系统调用 ，产生访管中断，\n进入操作系统；\n操作系统为发送进程分配一个空缓冲区，并将所发送的消息从发\n送进程copy到缓冲区中，然后将该载有消息的缓冲区连接到接收\n进程的消息链链尾，如此就完成了发送过程；\n发送进程返回到用户态继续执行；\n在以后某个时刻，当接收进程执行到 receive接收原语 时，也产\n生访管中断进入操作系统。\n由操作系统将载有消息的缓冲区从消息链中取出，并把消息内容\ncopy到接收进程空间，之后收回缓冲区，如此就完成了消息的接\n收，接收进程返回到用户态继续进行74\n\n--- 第63页 ---\n消息缓冲实现图示\n75\n\n--- 第64页 ---\nLecture 1. page 76\n消息缓冲区结构\ntype struct message_buffer ｛\nint sender;  // 发送者 ID\nint size;       // 消息长度\nchar *text;         // 消息正文\nstruct message_buffer *next;     \n//指向下一个消息缓冲区的指针\n｝76\n\n--- 第65页 ---\nLecture 1. page 77\nPCB\n中有关通信的数据项\ntype struct PCB｛\n…\nstruct message_buffer mq;   //消息队列首指针\nsemaphore mutex ; //消息队列互斥信号量，初值为 1\nsemaphore sm;    //消息队列资源信号量，初值为 0\n…\n｝77",
      "chunk_index": 12
    },
    {
      "text": "0\n…\n｝77\n\n --- 第66页 ---\n78\n发送原语和接收原语\nReceive(b ）\n{\n获得接收进程 PCB的指针q;\nwait(q.sm);\nwait(q.mutex);\n从q.mq中取下第一个\n消息缓冲区 i；\nsignal(q .mutex);\n将i中的内容复制到接收\n区b中，并释放 i \n} Send（R,a）\n{\n根据R找接收进程 ,如果没找到出错返回 ;\ngetbuf(a .size,i);/*根据消息长度\na.size，申请一个空缓冲区 i\n把消息从发送区 a中复制到空缓冲区 i中;\n获得接收进程 PCB的指针q;\nwait(q.mutex);\n将i挂到消息队列 q.mq的队尾;\nsignal(q .mutex);\nsignal(q.sm); \n}  \nsm初值:0\n\n--- 第67页 ---\nLecture 1. page 79\n消息传递通信的间接通信方式\n间接通信方式（信箱通信）\n发送进程发消息时不指定接收进程的名字，而是指定一个中间媒\n介，即信箱。进程间通过信箱实现通信\n发送原语： send(MB,Message )，接收原语： receive( MB,Message )\n信箱\n٭存放信件的存储区域\n٭构成\n信箱头：信箱容量 、信件格式 、信箱名称等；\n信箱体：若干格子 ，用来存放信件；79\n发送\n进程\nA…邮箱体邮箱头接收\n进程\nBDeposite\n(m)Remove\n(m)\n邮箱通信结构\n\n--- 第68页 ---\nLecture 1. page 80\n消息传递通信的间接通信方式\n分类\n٭私用信箱 --用户进程 /私有变量 /单向通信链路\n٭共享信箱 --操作系统 /全局变量 /双向通信链路\n٭公用信箱 --用户进程 /可共享\n信箱使用规则\n٭若发送信件时信箱已满，则发送进程被置为“等信箱”状态，\n直到信箱有空时才被唤醒\n٭若取信件时信箱中无信，则接收进程被置为“等信件”状态，\n直到有信件时才被唤醒80\n\n--- 第69页 ---\nLecture 1. page 81\n思考题\n在间接通信时，用 send(N,M) 原语发送信件 ，其中 M\n表示 。\nA．发送信件的进程名\nB．接收信件的进程名\nC．信箱名\nD．信件内容81\nD",
      "chunk_index": 13
    },
    {
      "text": "。\nA．发送信件的进程名\nB．接收信件的进程名\nC．信箱名\nD．信件内容81\nD\n\n --- 第70页 ---\nLecture 1. page 82\n第\n2\n章\n进程的描述与控制\n2.1  前趋图和程序执行\n2.2  进程的描述\n2.3  进程控制\n2.4  进程通信\n2.5  线程的概念\n2.6  线程的实现\n\n--- 第71页 ---\n可拥有资源 的独立单位\n给每个进程分配空间，保存进程映像，控制一些资源\n（文件， I/O设备）\n可独立调度和分派 的基本单位\n进程是一个执行轨迹\n以上两个属性构成进程并发执行的基础\n进程\n的两个基本\n 属性\n\n--- 第72页 ---\nLecture 1. page 84\n线程的\n引入（\n进程模型的\n 局限性\n）\n程序并发执行所需付出的时空开销：\n٭每个进程都有一个比较大的进程控制块 (PCB)，且它们需常驻\n内存。当进程数目比较多时 ，PCB集合占用的内存量是不可\n忽视的。因而内存开销比较大 。\n٭创建进程 ——分配除处理机以外的所有 资源，并建立 PCB\n٭撤销进程 ——回收资源 ，撤销 PCB\n٭进程切换 ——需要保留当前进程的 CPU环境，设置新选中进\n程的 CPU环境84\n\n--- 第73页 ---\nLecture 1. page 87\n线程的引入\n资源分配单位； 独立调度单位\n存在的问题\n进程作为一个资源拥有者，在创建、撤消、切换中，系统必须为\n之付出较大时空开销。所以系统中进程的数量不宜过多，进程切换的\n频率不宜过高，但这也就限制了并发程度的进一步提高。\n解决问题的思路\n把进程的两项功能－－ “独立分配资源 ”与“被调度分派执行 ”\n分离开来， 即资源的分配单位不一定是独立运行单位。\n进程作为系统资源分配和保护的独立单位，不需要频繁地切换；\n线程作为系统调度和分派的基本单位，能轻装运行，会被频繁地\n调度和切换，在这种指导思想下，产生了线程的概念87\n\n--- 第74页 ---\nLecture 1. page 88\n线程的引入\n引入进程的目的\n是为了使多个程序并发执行 ，以改善资源利用\n率、提高系统吞吐量 。\n引入线程的目的\n是为了减少进程并发执行时所付出的时空开销，\n使OS具有更好的并发性。88",
      "chunk_index": 14
    },
    {
      "text": "。\n引入线程的目的\n是为了减少进程并发执行时所付出的时空开销，\n使OS具有更好的并发性。88\n\n --- 第75页 ---\nLecture 1. page 89\n进程与线程的关系89\n单进程\n单线程单进程\n多线程\n多进程\n每个进程只有一个线程多进程\n每个进程有多个线程\n操作系统中的进程和线程可以设计为以上四种\n\n--- 第76页 ---\nLecture 1. page 91\n线程与进程的比较（\n 1\n）\n组成结构\n线程具有进程的许多特征 ，故又称轻型进程 ，传统进\n程称重型进程 。在引入线程的 OS中，每一进程都拥有\n多个线程 ，至少一个 。91\n\n--- 第77页 ---\n线程与进程的比较（\n 2\n）\n调度的基本单位\n在传统 OS中，拥有资源 、独立调度和分派的基本单位都是进程 。在\n引入线程的系统中 ，线程是调度和分派的基本单位 ，而进程是拥有资源\n的基本单位 ，不是调度的基本单位 ，所以每个进程在创建时 ，至少需要\n同时为该进程创建一个线程 ，也就是说进程中至少要有一个或一个以上\n线程，否则该进程无法被调度执行 。\n在同一个进程内线程切换不会产生进程切换 ，由一个进程内的线程\n切换到另一个进程内的线程时 ，将会引起进程切换 。\n并发性\n在引入线程的系统中，进程之间可并发，同一进程内的各线程之间\n也能并发执行。因而系统具有更好的并发性。\n\n--- 第78页 ---\nLecture 1. page 93\n线程与进程的比较（\n 3\n）\n拥有资源\n无论是传统 OS，还是引入线程的 OS，进程都是拥有资源的独立单位 ，\n线程一般不拥有系统资源 ，但它可以访问隶属进程的资源 。即一个进程\n的所有资源可供进程内的所有线程共享 。\n独立性\n在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得 多\n系统开销\n进程的创建和撤消的开销要远大于线程创建和撤消的开销 ，进程切换\n时，当前进程的 CPU环境要保存 ，新进程的 CPU环境要设置 ，线程切换\n时只须保存和设置少量寄存器 ，并不涉及存储管理方面的操作 ，可见，\n进程切换的开销远大于线程切换的开销 。\n同时，同一进程内的各线程由于它们拥有相同的地址空间 ，它们之\n间的同步和通信的实现也变得比较容易 。",
      "chunk_index": 15
    },
    {
      "text": "。\n\n --- 第79页 ---\n线程的状态\n与传统的进程一样 ，各线程之间也存在着共享资源和相互合\n作的制约关系 ，致使线程在运行时也具有间断性 。相应地，\n线程在运行时也具有下列三种基本状态：\n•执行状态\n•就绪状态\n•阻塞状态\n 线程之间的状态转\n换和进程之间的状\n态转换一样。\n\n--- 第80页 ---\n线程控制块\n TCB\n将所有用于 控制和管理线程的信息记录在 TCB中。TCB的\n组成：\n•线程标识符\n•一组寄存器： PC、状态寄存器 、通用寄存器\n•线程运行状态\n•优先级\n•线程专有存储 区\n•信号屏蔽\n•堆栈指针\n\n--- 第81页 ---\nLecture 1. page 96\n线程的\n类型\n内核支持线程\n٭线程的管理是利用系统调用 ，依赖于内核来实现的 。即无\n论是用户进程中的线程 ，还是系统进程中的线程 ，它们的\n创建、撤消、切换都由内核实现 。\n٭以线程为单位进行调度 。\n٭例子：Windows 2000/XP/NT，OS/2\n用户级线程\n٭对于这种线程的创建 、撤消、和切换，都不用系统调用来\n实现。可以通过 线程库来实现。\n٭内核并不知道用户级线程的存在 。\n٭以进程为单位进行调度 。96\n\n--- 第82页 ---\nLecture 1. page 97\n线程的类型举例\n有两个进程 A、B，如果采用轮转法调度\n若A有1个内核支持线程 ，B有100个内核支持线程 ，\n则进程 B获得 CPU的时间是进程 A的100倍。\n若A有1个用户级线程 ，B有100个用户级线程 ，则\n进程 A中线程的运行时间是进程 B中各线程运行时\n间的 100倍。97\n\n--- 第83页 ---\nLecture 1. page 98\n图：内核支持线程和用户级线程98\n\n--- 第84页 ---\nLecture 1. page 99\n内核支持线程的\n 实现\n创建新进程，为进程建立若干个 TCB空间。\n进程创建线程时，为线程分配 TCB，并填\n写相关信息。\n撤销线程时，进程回收 TCB和资源。\n调度以线程为单位，算法与进程类似。99",
      "chunk_index": 16
    },
    {
      "text": "TCB和资源。\n调度以线程为单位，算法与进程类似。99\n\n --- 第85页 ---\nLecture 1. page 100\n内核支持线程的优缺点\n优点：\n对多 CPU系统可以同时调度同一进程中的多个线程\n并行执行。\n当一个线程被阻塞时，系统可以调度同一进程或其\n他进程中的线程执行。\n只拥有很少的资源，切换速度较快。\n缺点：\n在同一进程内的线程切换调用内核，导致速度下降100\n\n--- 第86页 ---\nLecture 1. page 101\n用户级线程的\n 实现\n线程库\n٭构成：管理和控制线程的函数（过程）集合\n٭“线程库”驻留用户空间\n٭是用户级线程与内核之间的接口\n线程的创建、撤消、切换和通信，都无需利\n用系统调用来实现，调用线程库中的过程即\n可。\n核心不知道线程的存在\n\n--- 第87页 ---\nLecture 1. page 102\n用户级线程的优缺点\n优点：\n用户级线程的切换操作简单、速度快。\n线程库及所需的数据结构都在用户空间，节省了内核的宝贵\n资源。\n调度是应用程序特定的：可以选择最好的算法。\nULT可运行在任何操作系统上（只需要线程库），可以在一\n个不支持线程的 OS上实现。\n缺点：\n大多数系统调用是阻塞的，因此内核阻塞进程，故进程中所\n有线程将被阻塞。\n内核只将处理器分配给进程，同一进程中的两个线程不能同\n时运行于两个处理器上。",
      "chunk_index": 17
    }
  ]
}